# 10.5 泛型算法结构

算法对其使用的迭代器类别有要求。

## 10.5.1 5 类迭代器

* 输入迭代器（input iterator）：只读、不写；单遍扫描，只能递增
* 输出迭代器（output iterator）：只写、不读；单遍扫描，只能递增
* 前向迭代器（forward iterator）：可读可写；多遍扫描，只能递增
* 双向迭代器（bidirectional iterator）：可读可写；多遍扫描，可递增递减
* 随机访问迭代器（random-access iterator）：可读可写；多遍扫描，支持全部迭代器运算

向算法传递一个能力更差的迭代器会产生错误。

### 输入迭代器

* 可以比较两个迭代器相等和不等（== 、!=）
* 可以递增（++）
* 可以读取指向的元素（解引用 * 只会出现在赋值运算符右侧）
* 可以提取对象的成员（->）

输入迭代器只用于顺序访问、单遍扫描算法。  
算法 find 和 accumulate 要求输入迭代器；  
istream_iterator 是一种输入迭代器。

### 输出迭代器

* 可以递增（++）
* 可以写入指向的元素（解引用 * 只会出现在赋值运算符左侧）

只能向输出迭代器赋值一次，只用于单遍扫描算法。  
算法 copy 的第三个参数是输出迭代器；  
ostream_iterator 是一种输出迭代器。

### 前向迭代器

* 支持**输入迭代器**和**输出迭代器**的所有操作
* 只能沿一个方向移动
* 可以多次读写同一个元素（多遍扫描）

算法 replace 要求前向迭代器；  
forward_list 上的迭代器是前向迭代器。

### 双向迭代器

* 支持**前向迭代器**的所有操作
* 可以正向/反向移动（++/--）

算法 reverse 要求双向迭代器；  
除了 forward_list ，其他标准库的迭代器都满足双向迭代器的要求。

*list 的迭代器是双向迭代器，但不是随机访问迭代器。*

### 随机访问迭代器

* 支持**双向迭代器**的所有操作
* 可以比较两个迭代器的相对位置（< 、<= 、> 、>=）
* 可以和整数值进行加减运算（+ 、+= 、- 、-=）
* 可以将两个迭代器相减（-），得到两个迭代器的距离
* 支持下标运算符（[]）

算法 sort 要求随机访问迭代器；  
只有 array 、deque 、string 、vector 的迭代器和内置数组的指针是随机访问迭代器。

## 10.5.2 算法形参模式

大多数算法具有以下 4 种形式之一：

1. `alg(beg, end, other args);`
2. `alg(beg, end, dest, other args);`
3. `alg(beg, end, beg2, other args);`
4. `alg(beg, end, beg2, end2, other args);`

* `alg` ：算法的名字
* `beg` 、`end` ：算法的输入范围
* `dest` ：目的位置
* `beg2` 、`end2` ：第二个范围

### 接受单个目标迭代器的算法

`dest` 表示算法可以写入的目的位置。

算法假定：按照需要写入数据，无论写入多少个元素都是安全的。

*注意：向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。*

`dest` 是：

1. 指向容器的迭代器：算法将输出数据写到容器中已存在的元素内
2. 插入迭代器：将新元素添加到容器中
3. ostream_iterator ：将数据写入输出流

### 接受第二个输入序列的算法

单独使用 `beg2` 或同时使用 `beg2` 和 `end2` 表示第二个输入范围。

算法要求：接受单独的 `beg2` 的算法，从 `beg2` 开始的序列长度要**大于等于**输入范围 `beg` 和 `end` 的长度。

## 10.5.3 算法命名规范

算法使用重载形式传递一个谓词：

```cpp
// 函数名相同，接受参数的数量不同（是重载）
unique(beg, end);       // 使用 == 运算符比较元素
unique(beg, end, comp); // 对 unique 重载，使用 comp 比较元素
```

接受一个元素值的算法通常存在一个 `_if` 版本的算法，该版本的算法接受一个谓词代替元素值。

```cpp
// 函数名不同，接受参数的数量相同（不是重载，防止有歧义）
find(beg, end, val);     // 查找 val 第一次出现的位置
find_if(beg, end, pred); // 查找使 pred 为真的第一个元素的位置
```

算法分为拷贝元素的版本和不拷贝元素的版本：

```cpp
reverse(beg, end); // 不拷贝元素，直接在输入范围上反转
reverse_copy(beg, end, dest); // 输入范围内的元素不变，将反转的结果拷贝到 dest
```

同时提供 `_copy` 和 `_if` 版本的算法：

```cpp
remove_if(beg, end, pred); // 将使 pred 为真的元素从输入范围中删除
remove_copy_if(beg, end, dest, pred); // 将使 pred 为真的元素删除后的序列拷贝到 dest 指向的位置
```

## 练习

* [练习 10.38](../src/quiz_10.38.md)
* [练习 10.39](../src/quiz_10.39.md)
* [练习 10.40](../src/quiz_10.40.md)
* [练习 10.41](../src/quiz_10.41.md)
