# 15.7 构造函数与拷贝控制

## 15.7.1 虚析构函数

应该将基类中的析构函数定义成虚函数以确保执行正确的析构函数版本。

如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针，将产生未定义的行为。

如果一个类定义了析构函数，即使它通过 `=default` 的形式使用了合成的版本的移动操作，编译器也不会为这个类合成移动操作。

## 15.7.2 合成拷贝控制与继承

合成的拷贝控制成员**首先**使用直接基类的对应操作对直接基类部分进行初始化、赋值，**然后**再对自己独有的部分进行初始化、赋值（销毁的顺序相反）。

基类或派生类的拷贝控制成员也可能被定义为删除的函数（见 [13.1.6 节](../../Chapter13_%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/note/note_13.1.md)和 [13.6.2 节](../../Chapter13_%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/note/note_13.6.md)）。  
此外，某些定义**基类**的方式也可能导致有的**派生类成员**被定义为删除的函数：

* 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的（因为派生类无法使用基类对应的成员完成派生类对象基类部分的操作）
* 如果在基类中有一个不可访问或删除的析构函数，则派生类中合成的默认构造函数和拷贝构造函数是删除的（因为派生类无法使用基类的析构函数销毁派生类对象的基类部分）
* 如果基类中的移动操作是删除的或不可访问的，那么派生类的移动构造函数是删除的
* 如果基类的析构函数是删除的或不可访问的，那么派生类的移动构造函数也是删除的

当我们确实需要执行移动操作时，应该首先在基类中显式地定义相应的函数（可以使用 `=default` 合成的版本）。这样派生类才会自动获得合成的移动操作。

## 15.7.3 派生类的拷贝控制成员

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括自有成员和基类部分在内的全部对象。

```cpp
class Base { /* ... */ };

class D : public Base {
public:
    // 拷贝构造函数
    D(const D &d) : Base(d) /* 调用 Base 的拷贝构造函数拷贝基类部分 */ /* 拷贝 D 的自有成员 */ { }

    // 移动构造函数
    D(D &&d) : Base(std::move(d)) /* 调用 Base 的移动构造函数移动基类部分 */ /* 移动 D 的自有成员 */ { }

    // 拷贝赋值运算符
    D &operator=(const D &rhs)
    {
        Base::operator=(rhs); // 调用 Base 的拷贝赋值运算符拷贝基类部分
        // 拷贝 D 的自有成员
        return *this;
    }
};
```

派生类析构函数只负责销毁由派生类自己分配的资源。

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。  
即：在 Base 的构造函数/析构函数中调用的虚函数应该匹配 Base 中定义的版本；在 D 的构造函数/析构函数中调用的虚函数应该匹配 D 中定义的版本。

## 15.7.4 继承的构造函数

使用 using 语句可以直接“继承”直接基类的全部构造函数。  
对于直接基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。  
对于派生类的自有数据成员，将执行默认初始化。

例：

```cpp
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote; // Disc_quote 的各种构造函数都在 Bulk_quote 中定义
};
```

以下 2 种例外情况会导致不是所有的构造函数都被继承：

1. 如果派生类定义的构造函数与直接基类的构造函数具有相同的形参列表，那么对应的构造函数不会继承，而是直接使用派生类定义的构造函数
2. 默认构造函数、拷贝构造函数和移动构造函数均不会被继承，这些构造函数由编译器合成

使用 using 声明的构造函数不会改变对应构造函数的访问级别。在基类中是 private/protected/public 的构造函数，在派生类中仍然是 private/protected/public 的。  
在基类中是 explicit 或 constexpr 的构造函数，在派生类中仍然具有该属性。

如果基类中的构造函数含有默认实参，则会在派生类中生成多个对应的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。

例：

```cpp
参数列表：(int a, int b = 5, int c = 10)

派生类对应的构造函数：
(int a, int b, int c)
(int a, int b) // c 取 10
(int a) // b 取 5 ，c 取 10
```

## 练习

* [练习 15.24](../src/quiz_15.24.md)
* [练习 15.25](../src/quiz_15.25.md)
* [练习 15.26](../src/quiz_15.26.cpp)
* [练习 15.27](../src/quiz_15.27.md)
