# 15.2 定义基类和派生类

> 本章术语：
>
> * 覆盖（override）：派生类需要用自定义版本的函数覆盖基类虚函数的定义
> * 直接基类（direct base）：出现在类派生列表中的类
> * 间接基类（indirect base）：直接基类的基类成为间接基类
> * 静态类型（static type）：在编译时是已知的
> * 动态类型（dynamic type）：直到运行时才是已知的

## 15.2.1 定义基类

基类通常都应该定义一个虚析构函数。

基类将以下两种函数进行区分：

1. 基类希望派生类直接继承而不改变的函数
2. 基类希望派生类进行覆盖的函数（虚函数）

派生类可以访问基类的公有成员，不能访问基类的私有成员。

如果基类希望派生类访问某个成员，但是不希望其他与之无关的代码访问该成员，那么该成员应该声明在 `protected:` 访问说明符下。

## 15.2.2 定义派生类

派生类必须通过使用类派生列表指明它从哪个（哪些）基类继承而来。  
类派生列表以冒号开头，后面紧跟以逗号分隔的基类列表，基类前面是访问说明符 public 、protected 、private 中的一个。

派生类的声明**不包含**类派生列表。

派生类必须重新声明基类中的虚函数。  
如果派生类覆盖了基类的虚函数，则应该在声明末尾添加 override 关键字。

派生类由两部分构成：

1. 派生类自定义的成员
2. 基类拥有的成员

派生类的对象可以当成基类对象使用。  
可以将基类的指针或引用绑定到派生类对象的基类部分上。

派生类的构造函数必须调用基类的构造函数来初始化属于基类的部分。  
如果不显式调用基类的构造函数，那么基类部分会执行默认初始化。

*每个类控制其自己的成员初始化过程。*  
*首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。*

派生类可以访问基类的公有成员和受保护的成员，不能访问私有成员。

*不应该通过直接给基类的公有成员和受保护的成员赋值的方式初始化派生类的基类部分。*  
*应该使用基类的构造函数完成派生类基类部分的初始化。*

如果基类定义了一个静态成员，那么在整个继承体系中该静态成员只存在唯一的定义。静态成员的访问控制规则与普通成员相同。

作为基类的类必须被定义，而不仅是声明。  
一个类不能派生它本身。

最终的派生类将包含它的直接基类的子对象，以及每个间接基类的子对象。

在类名后添加 final 关键字，可以阻止该类作为其他类的基类：`class NoDerived final {};`

## 15.2.3 类型转换与继承

智能指针、内置指针、引用都支持派生类向基类的类型转换。  
不存在基类向派生类的隐式类型转换。  
即使一个基类指针或引用绑定在一个派生类对象上，也不能将该指针或引用赋予派生类：

```cpp
Bulk_quote bulk;
Quote *baseP = &bulk; // 指向派生类的基类指针
Bulk_quote *deriveP = baseP; // 错误：即使本身是绑定到派生类的指针，基类指针也不能转换为派生类指针
```

基类的指针或引用的静态类型可能与其动态类型不一致；  
如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

总结：

* 从派生类向基类的类型转换只对指针或引用类型有效
* 基类向派生类不存在隐式类型转换
* 派生类向基类的类型转换也可能会由于访问受限而变得不可行

## 练习

* [练习 15.1](../src/quiz_15.1.md)
* [练习 15.2](../src/quiz_15.2.md)
* [练习 15.3](../src/quiz_15.3.md)
* [练习 15.4](../src/quiz_15.4.md)
* [练习 15.5](../src/quiz_15.5.md)
* [练习 15.6](../src/quiz_15.6.cpp)
* [练习 15.7](../src/quiz_15.7.hpp)
* [练习 15.8](../src/quiz_15.8.md)
* [练习 15.9](../src/quiz_15.9.cpp)
* [练习 15.10](../src/quiz_15.10.md)
