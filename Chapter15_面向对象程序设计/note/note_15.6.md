# 15.6 继承中的类作用域

派生类的作用域嵌套在基类的作用域**之内**。

如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

定义在内层作用域（派生类）的名字将隐藏定义在外层作用域（基类）的名字。

*派生类的成员将隐藏同名的基类成员。*

可以通过作用域运算符来使用被隐藏的成员。

*除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。*

成员函数调用（`obj.mem()` 或 `p->mem()`）的 4 个步骤：

1. 首先确定 `obj` 或 `p` 的静态类型是类类型
2. 在 `obj` 或 `p` 的作用域中查找 `mem` ，如果找不到，则向外层基类作用域逐层查找，直到继承链的顶端（依旧找不到时编译器报错）
3. 一旦找到 `mem` ，就进行常规的类型检查，确认本次调用的合法性
4. 调用合法时，编译器将根据调用是否是虚函数而产生不同的代码：
   * 是虚函数且通过引用或指针进行调用：依据对象的动态类型进行动态绑定（运行时确定虚函数的版本）
   * 不是虚函数或通过对象（而非引用或指针）进行调用：在编译时确定调用函数的版本

声明在内层作用域的函数并不会重载声明在外层作用域的函数。  
派生类中的成员函数也不会重载基类中的成员函数。

对于**相同的成员函数名**，即使派生类成员函数的**形参列表**和基类成员函数**不一致**，基类成员函数也会被隐藏掉（使用作用域运算符调用被隐藏的成员）。  

当派生类想覆盖基类的重载函数时，要么覆盖重载函数的所有版本，要么一个也别覆盖。  
如果想只覆盖重载函数的一部分版本，那么需要使用 using 语句在派生类中声明重载函数的名字而不指定形参列表，然后定义需要的重载函数版本。

```cpp
class Base {
public:
    virtual int fcn();
};

class D1 : public Base {
public:
    int fcn(int); // 形参列表与 Base 中的 fcn 不一致，因此这个 fcn 不是虚函数，没有覆盖 Base 的定义（Base 的 fcn 被隐藏）
    virtual void f(); // 定义了一个新的虚函数 f
};

class D2 : public D1 {
public:
    int fcn(int); // 情况与 D1 相同（D1 的 fcn 被隐藏）
    int fcn(); // 形参列表与 Base 中的 fcn 一致，是虚函数，覆盖了 Base 中的 fcn
    void f(); // 形参列表与 D1 中的 f 一致，是虚函数，覆盖了 D1 中的 f
};

Base b_obj;
D1 d1_obj;
D2 d2_obj;
// 调用虚函数时执行动态绑定
// 调用普通函数时执行静态绑定

Base *bp1 = &b_obj, *bp2 = &d1_obj, *bp3 = &d2_obj;
bp1->fcn(); // 虚调用，动态绑定，运行时调用 Base::fcn()
bp2->fcn(); // 虚调用，动态绑定，运行时调用 Base::fcn()（D1 没有覆盖虚函数）
bp3->fcn(); // 虚调用，动态绑定，运行时调用 D2::fcn()（D2 覆盖了虚函数）

D1 *d1p = &d1_obj;
D2 *d2p = &d2_obj;
bp2->f(); // 错误：在 Base 中找不到函数名字 f
d1p->f(); // 虚调用，动态绑定，运行时调用 D1::f()
d2p->f(); // 虚调用，动态绑定，运行时调用 D2::f()

Base *p1 = &d2_obj;
D1   *p2 = &d2_obj;
D2   *p3 = &d2_obj;
p1->fcn(42); // 错误：在 Base 中找不到接受 int 版本的 fcn
p2->fcn(42); // 普通调用，静态绑定，编译时调用 D1::fcn(int)
p3->fcn(42); // 普通调用，静态绑定，编译时调用 D2::fcn(int)
```

## 练习

* [练习 15.23](../src/quiz_15.23.md)
