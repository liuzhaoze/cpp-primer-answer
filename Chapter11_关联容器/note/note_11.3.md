# 11.3 关联容器操作

关联容器额外的类型别名：

* `key_type` ：该容器类型的关键字类型
* `mapped_type` ：每个关键字所关联的类型，只适用于 map
* `value_type` ：对于 set ，与 `key_type` 相同；对于 map ，则是 `pair<const key_type, mapped_type>`

*注意：不能改变 pair 的第一个元素的值，即：不能改变关键字。*

## 11.3.1 关联容器迭代器

map 的迭代器是指向 pair 类型的；  
set 的迭代器是指向关键字的，关键字不能修改，所以 set 的迭代器是 const 的。

可以像**顺序容器**一样使用迭代器遍历**关联容器**。  
有序容器（map 、multimap 、set 、multiset）都是按关键字升序储存元素的。

通常不对关联容器使用泛型算法。如果一定要对关联容器使用算法，它应当作为：

1. 一个源序列：使用 copy 将元素从一个关联容器中拷贝到别的地方
2. 一个目的位置：将插入器 inserter 绑定到一个关联容器上，在算法中通过 inserter 向关联容器中添加元素

## 11.3.2 添加元素

向 map 和 set 中插入一个已存在的元素对容器没有任何影响。  
对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。  
即：只有关键字不在容器中时，才会被插入到容器中，如果关键字已存在，即使值不同也不会插入。

* `c.insert(v)` ：v 是 value_type 类型的对象
* `c.emplace(args)` ：args 用来构造 value_type 类型的对象

上述两个函数返回一个 pair 。第一个成员是一个迭代器，指向具有指定关键字的元素；第二个成员是一个 bool 值，指示插入是否成功。  
对于 multimap 和 multiset ，总会插入给定元素，并返回指向新插入元素的迭代器，而不会返回 bool 值。

* `c.insert(b, e)` ：b 和 e 是迭代器，表示一个 c::value_type 类型值的范围
* `c.insert(il)` ：il 是花括号列表，列表中的元素是 c::value_type 类型

上述两个函数返回 void 。

* `c.insert(p, v)` ：迭代器 p 指出从哪里开始搜索新元素应该插入的位置
* `c.insert(p, args)` ：迭代器 p 指出从哪里开始搜索新元素应该插入的位置

上述两个函数返回一个迭代器，指向具有指定关键字的元素。

## 11.3.3 删除元素

* `c.erase(k)` ：从 c 中删除所有关键字为 k 的元素，返回一个 size_type 值，指出所删除的元素的数量
* `c.erase(p)` ：从 c 中删除迭代器 p 所指向的元素。p 必须指向 c 中真实存在的元素，不能等于 c.end() 。返回一个指向 p 之后元素的迭代器，如果 p 指向 c 的尾元素，则返回 c.end()
* `c.erase(b, e)` ：删除迭代器对 b 和 e 所表示的范围中的元素，返回 e

## 11.3.4 map 的下标操作

## 练习

* [练习 11.15](../src/quiz_11.15.md)
* [练习 11.16](../src/quiz_11.16.cpp)
* [练习 11.17](../src/quiz_11.17.md)
* [练习 11.18](../src/quiz_11.18.cpp)
* [练习 11.19](../src/quiz_11.19.cpp)
* [练习 11.20](../src/quiz_11.20.cpp)
* [练习 11.21](../src/quiz_11.21.md)
* [练习 11.22](../src/quiz_11.22.md)
* [练习 11.23](../src/quiz_11.23.cpp)
