# 7.3 类的其他特性

> 本章术语：
>  
> * 可变数据成员（mutable data member）
> * 前向声明（forward declaration）
> * 不完全类型（incomplete type）：声明但没有定义的类类型

## 7.3.1 类成员再探

在类中定义类型别名：

```c
class Screen
{
public:
    typedef std::string::size_type pos;
    // 等价于
    using pos = std::string::size_type;

private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

如果 `pos` 定义为公有的，那么用户就可以使用这个名字。  
如果 `pos` 定义为私有的，那么用户就不能使用这个名字。

用来定义类型的成员必须先定义，后使用。因此，类型成员通常出现在类开始的地方。

定义在类内部的成员函数是自动 inline 的。  
可以在类的内部把 inline 作为声明的一部分显式地声明成员函数，也可以在类的外部用 inline 关键字修饰函数的定义。  
*最好只在类外部定义的地方说明 inline ，这样可以使类更容易理解。*

成员函数也可以被重载。

可变数据成员：在变量的声明中加入 `mutable` 关键字后，该变量即使是在一个 const 成员函数内，也可以被修改。  
可变数据成员永远不会是 const 。

当我们提供一个类内初始值时，必须以符号 `=` 或者 花括号 表示。

## 7.3.2 返回 *this 的成员函数

如果成员函数的返回类型是引用，则返回 `*this` 是该对象本身。  
如果成员函数的返回类型是普通类型，则返回 `*this` 是该对象的副本。  
一个 const 成员函数如果以引用的形式返回 `*this` ，那么他的返回类型将是常量引用。

*对于公共代码使用私有功能函数。*

## 7.3.3 类类型

即使两个类的成员列表完全一致，他们也是不同的类型。  
对于一个类来说，他的成员和其他任何类的成员都不是一回事儿。

前向声明：只声明而不定义类类型 `class Screen`  
`Screen` 类在声明之后、定义之前是一个不完全类型。

不完全类型的使用情景：

1. 定义指向这种类型的指针或引用
2. 声明（但是不能定义）以不完全类型作为参数或返回类型的函数

类允许包含指向他自身类型的引用或指针。

## 7.3.4 友元再探

普通的非成员函数可以定义为友元；其他类可以定义为友元；其他类的成员函数可以定义为友元。  
友元函数可以定义在类的内部，该函数是隐式内联的。

如果一个类指定了友元类，则友元类的成员函数可以访问该类包括非公有成员在内的所有成员。

```c
class Screen {
    friend class Window_mgr;
};
```

友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。

当把一个成员函数声明成友元时，必须明确指出该成员函数属于哪个类。

```c
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
};
```

如果一个类想把一组重载函数声明成他的友元，需要对这一组函数中的每一个分别声明。

即使在类的内部声明或定义友元函数，我们也**必须在类的外部**再声明或定义该函数，从而使得函数可见。

```c
struct X {
    friend void f() {
        /* 友元函数定义在类的内部 */
    }

    X() { f(); }             // 错误： f 没有在类的外部声明
    
    void g();
    void h();
};

void X::g() { return f(); }  // 错误： f 没有在类的外部声明
void f();                    // 在类的外部声明 f
void X::h() { return f(); }  // 正确：声明 f 后，该函数可见
```

## 练习

* [练习 7.23](../src/quiz_7.23.hpp)
* [练习 7.24](../src/quiz_7.24.hpp)
* [练习 7.25](../src/quiz_7.25.md)
* [练习 7.26](../src/quiz_7.26.hpp)
* [练习 7.27](../src/quiz_7.27.hpp)
* [练习 7.28](../src/quiz_7.28.md)
* [练习 7.29](../src/quiz_7.29.hpp)
* [练习 7.30](../src/quiz_7.30.md)
* [练习 7.31](../src/quiz_7.31.cpp)
* [练习 7.32](../src/quiz_7.32.hpp)
