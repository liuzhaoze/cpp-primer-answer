# 2.3 复合类型

> 本章术语：
>  
> * 复合类型（compound type）：基于其他类型定义的类型，如：引用、指针。
> * 引用（reference）：为对象起了另外一个名字。
> * 指针（pointer）

## 2.3.1 引用

```c
int ival = 1024;
int &refVal = ival;  // refVal 指向 ival （是 ival 的另一个名字）
int &refVal2;        // 错误：引用必须被初始化
```

引用是对象的别名，引用本身不是对象。因此不能定义引用的引用。

定义引用时，**每个**引用标识符都必须以符号 `&` 开头。

一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

## 2.3.2 指针

指针本身就是一个对象，允许赋值和拷贝。
在生命周期内可以先后指向不同的对象。  
指针无须在定义时赋初值。

定义指针变量时，**每个**变量前面都必须有符号 `*` 。

指针变量存放某个对象的地址，该地址需要使用取地址符（`&`）得到。

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

对指针变量使用解引用符（`*`）来访问对象。

在声明语句中， `&` 和 `*` 用于组成复合类型；在表达式中，它们的角色又转变成运算符。

使用字面值 `nullptr` 初始化指针，以得到空指针：
`int *p = nullptr;` 等价于 `int *p = 0;`  
*建议初始化所有指针*

指针的值是 0 ，条件取 false ；任何非 0 指针对应的条件值都是 true 。

对于两个**类型相同**的合法指针，可以用相等操作符（`==`）或不相等操作符（`!=`）来比较它们。

`void *` 指针类型可用于存放任意对象的地址。  
该类型可以和别的指针比较，作为函数的输入输出，或者赋值给另外一个 `void *` 指针。但不能直接操作 `void *` 指针所指的对象。

## 2.3.3 理解复合类型的声明

指向指针的引用：

```c
int i = 42;
int *p;       // p 是一个 int 型指针
int *&r = p;  // r 是一个对指针 p 的引用
```

要理解 r 的类型到底是什么，最简单的办法是从右向左阅读 r 的定义。离变量名最近的符号（此例中是 &r 的符号 &）对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号 * 说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。

## 练习

* [练习 2.15](../src/quiz_2.15.md)
* [练习 2.16](../src/quiz_2.16.md)
* [练习 2.17](../src/quiz_2.17.cpp)
* [练习 2.18](../src/quiz_2.18.cpp)
* [练习 2.19](../src/quiz_2.19.md)
* [练习 2.20](../src/quiz_2.20.cpp)
* [练习 2.21](../src/quiz_2.21.md)
* [练习 2.22](../src/quiz_2.22.md)
* [练习 2.23](../src/quiz_2.23.md)
* [练习 2.24](../src/quiz_2.24.md)
* [练习 2.25](../src/quiz_2.25.md)
