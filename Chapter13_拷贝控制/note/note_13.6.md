# 13.6 对象移动

> 本章术语：
>
> * 左值引用（lvalue reference）：常规引用
> * 右值引用（rvalue reference）：必须绑定到右值的引用
> * 移动迭代器（move iterator）：解引用后得到右值引用
> * 引用限定符（reference qualifier）：位于参数列表后，用于限定成员函数中的 this 指向左值还是右值

标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝。
IO 类和 unique_ptr 类可以移动但不能拷贝。

## 13.6.1 右值引用

使用 `&&` 而非 `&` 来获得右值引用。

右值引用只能绑定到一个将要销毁的对象。  
右值引用只能绑定到临时对象。  
临时对象作为参数传递时，该临时对象是右值引用。

返回左值表达式的例子：

* 赋值运算符
* 下标运算符
* 解引用运算符
* 前置递增/递减运算符
* 返回左值引用的函数

上述表达式可以绑定在**左值引用**上。

返回右值表达式的例子：

* 算术运算符
* 关系运算符
* 位运算符
* 后置递增/递减运算符
* 返回非引用类型的函数

上述表达式可以绑定在**右值引用**或 **const 的左值引用**上，但是不能绑定在左值引用上。

```cpp
// 变量是左值
int &&rr1 = 42; // 正确：字面常量 42 是右值，可以绑定在右值引用 rr1 上
// rr1 是右值引用，是变量，是左值
int &&rr2 = rr1; // 错误：rr1 是左值，不能绑定在右值引用 rr2 上

int &&rr3 = std::move(rr1); // 正确：将左值 rr1 当作一个右值进行处理
// 对 rr1 使用 move 意味着：除了对 rr1 进行赋值或销毁之外，不能进行其他任何操作
// * 可以销毁 rr1
// * 可以赋予 rr1 新的值
// * 在赋予新值之前，不能使用 rr1 的值
```

*调用 move 时应该使用 `std::move` ，避免潜在的名字冲突。*

## 13.6.2 移动构造函数和移动赋值运算符

移动构造函数的形式：

* 第一个参数是该类类型的一个**右值引用**（拷贝构造函数是左值引用）
* 任何额外的参数都必须有默认实参（与拷贝构造函数相同）
* 必须保证销毁移后源对象是安全的，移后源对象不能再指向被移动的资源

移动构造函数示例：

```cpp
StrVec::StrVec(StrVec &&s) noexcept // 通知标准库：该构造函数不抛出任何异常
    : elements(s.elements), first_free(s.first_free), cap(s.cap) // 使用本对象接管 s 的所有内存
{
    s.elements = s.first_free = s.cap = nullptr; // 保证销毁 s 是安全的
    // 如果没有置为空指针，则销毁 s 的过程中，deallocate 会释放刚刚移动的内存
}
```

`noexcept` 出现在参数列表和初始化列表的冒号之间。

必须在声明和定义处都指定 `noexcept` 。

不抛出异常的移动构造函数和移动赋值运算符都必须标记为 `noexcept` 。

移动赋值运算符示例：

```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept // 右值引用、不抛出异常
{
    if (this != &rhs) // 自赋值的情况不需要移动内存
    {
        free(); // 释放 lhs 的内存

        // lhs 接管 rhs 的资源
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;

        // 保证销毁 rhs 是安全的
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }

    return *this;
}
```

移后源对象应该满足的状态：

* 执行析构函数是安全的
* 可以安全地将新值赋予移后源对象
* 可以安全地使用移后源对象，并且不依赖于其移动之后留下的值（无法确定留下的值到底是什么）

如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符，或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。  
如果一个类没有移动操作，类会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都定义了自己的移动构造函数或移动赋值运算符时，编译器才会为它合成移动构造函数或移动赋值运算符。  
编译器可以自己移动内置类型的成员。

移动操作永远不会隐式定义为删除的函数。  
如果显式要求编译器生成 `=default` 的移动操作，但是编译器不能移动所有成员，那么编译器会将移动操作定义为删除的函数。

以下情况，编译器将合成的移动操作定义为删除的函数：

* 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数（移动赋值运算符类似）
* 有类成员的移动操作被定义为删除的或是不可访问的
* 如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的（类似拷贝构造函数）
* 如果有类成员是 const 的或是引用，则类的移动赋值运算符被定义为删除的（类似拷贝赋值运算符）

如果不要求编译器生成 `=default` 的移动操作，在上述情况中，编译器根本不会生成任何移动操作。

定义了一个移动构造函数或移动赋值运算符的类，也必须定义自己的拷贝操作。否则所有拷贝操作默认地被定义为删除的函数。

对于左值，使用拷贝操作；对于右值，使用移动操作。  
如果一个类没有定义移动操作，则对于右值也使用拷贝操作。（即使调用 `std::move` 也使用拷贝操作）

使用拷贝并交换实现的赋值运算符可以同时作为拷贝赋值运算符和移动赋值运算符：

```cpp
class HasPtr
{
public:
    // 移动构造函数
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i)
    {
        p.ps = 0;
    }

    // 使用拷贝并交换技术的赋值运算符
    HasPtr &operator=(HasPtr rhs)
    {
        swap(*this, rhs);
        return *this;
    }
};

// 当 rhs 是左值时，= 代表拷贝赋值运算符
hp1 = hp2;
// 当 rhs 是右值时，= 代表移动赋值运算符
hp1 = std::move(hp2);
```

*5 个拷贝控制成员应该看作一个整体，只要定义就应该 5 个成员同时定义。包括：拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符。*

使用移动迭代器适配器将普通迭代器转换为一个移动迭代器，可以实现移动迭代器范围内元素的移动，而非拷贝：

```cpp
uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
```

*注意：不要随意使用移动操作。*  
*在类实现代码中的移动构造函数和移动赋值运算符中小心使用 `std::move` 可以大幅提升性能。*  
*在普通用户代码中要谨慎使用移动操作，需要保证移后源对象不会被再次使用。*

## 13.6.3 右值引用和成员函数

除了构造函数和赋值运算符之外，类的成员函数也可以同时提供拷贝版本和移动版本。  
拷贝版本接受一个指向 const 的左值引用 `const T &`  
移动版本接受一个指向非 const 的右值引用 `T &&`

当传递的参数是非 const 的右值引用时，函数匹配移动版本；其他情况下函数匹配拷贝版本。

### 编译器没有限制给右值赋值的操作

```cpp
string s1 = "a value", s2 = "another";
s1 + s2 = "wow!"; // 给右值赋值
```

需要通过引用限定符强制左侧运算对象必须是左值：

```cpp
class Foo {
public:
    Foo &operator=(const Foo &) &; // 这里的第二个 & 就是引用限定符
};

Foo &Foo::operator=(const Foo &rhs) & // 这样赋值运算符的左侧运算对象只能是左值，不能给右值赋值
{
    // ...
    return *this;
}
```

const 限定符和引用限定符只能用于非 static 成员函数，并且同时出现在函数的声明和定义中。

限定符作用于 this 成员。

成员函数同时使用 const 限定符和引用限定符时，引用限定符必须在 const 限定符之后：

```cpp
Foo member_function() const &;
```

### 可以通过 const 限定符和引用限定符区分成员函数的重载版本

```cpp
class Foo
{
private:
    vector<int> data;

public:
    Foo sorted() const &
    {
        // 本成员函数的 *this 是 const 或是左值，因此对象不能改变或者在其他地方使用，不能进行原址排序
        Foo ret(*this); // 因此对拷贝的副本进行排序
        sort(ret.data.begin(), ret.data.end());
        return ret;
    }

    Foo sorted() &&
    {
        // 本成员函数的 *this 是右值引用，没有别的地方使用该对象，可以进行原址排序
        sort(data.begin(), data.end())
        return *this; // 对本对象进行了移动
    }

    using Comp = bool(const int &, const int &);
    Foo sorted(Comp *);
    Foo sorted(Comp *) const;
};
```

`左值.sorted()` 会调用 `Foo sorted() const &`  
`右值.sorted()` 会调用 `Foo sorted() &&`

具有相同参数列表的同名成员函数，要么都加引用限定符，要么都不加；不能一个加一个不加：

```cpp
// 正确：参数列表都是 () ，都加引用限定符
Foo sorted() const &;
Foo sorted() &&;

// 正确：参数列表都是 (Comp *) ，都不加引用限定符
Foo sorted(Comp *) const;
Foo sorted(Comp *);

// 错误：一个添加了引用限定符，一个没添加引用限定符
    Foo sorted() const; // 没加
    Foo sorted() &&;    // 加了
    // 或
    Foo sorted() const &; // 加了
    Foo sorted();         // 没加
```

## 练习

* [练习 13.45](../src/quiz_13.45.md)
* [练习 13.46](../src/quiz_13.46.md)
* [练习 13.47](../src/quiz_13.47.hpp)
* [练习 13.48](../src/quiz_13.48.cpp)
* [练习 13.49](../src/quiz_13.49.md)
* [练习 13.50](../src/quiz_13.50.cpp)
* [练习 13.51](../src/quiz_13.51.md)
* [练习 13.52](../src/quiz_13.52.md)
* [练习 13.53](../src/quiz_13.53.cpp)
* [练习 13.54](../src/quiz_13.54.md)
* [练习 13.55](../src/quiz_13.55.md)
* [练习 13.56](../src/quiz_13.56.md)
* [练习 13.57](../src/quiz_13.57.md)
* [练习 13.58](../src/quiz_13.58.cpp)
