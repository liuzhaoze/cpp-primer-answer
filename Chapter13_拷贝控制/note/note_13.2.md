# 13.2 拷贝控制和资源管理

> 本章术语：
>
> * 引用计数（reference count）

类类型的拷贝语义有两种：

1. 类的行为看起来像一个值：拷贝得到的对象与原对象是完全独立的
2. 类的行为看起来像一个指针：拷贝得到的对象与原对象使用相同的底层数据，一方改变时另一方会随之改变

## 13.2.1 行为像值的类

编写赋值运算符时应当注意的点：

* 如果将一个对象赋予它自身，赋值运算符必须能正确工作
* 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
* 赋值运算符应该按以下步骤进行：
  1. 先将右侧运算对象拷贝到一个局部临时对象中
  2. 销毁左侧运算对象的现有成员
  3. 将数据从临时对象拷贝到左侧运算对象的成员中

如果颠倒步骤 1 和 2 ，会导致访问已释放的内存的错误：

```cpp
HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    delete ps; // 先释放了左侧运算对象的成员
    ps = new string(*(rhs.ps));
    // 错误：如果是自赋值，两侧运算对象相同，那么 rhs.ps 所指对象已经被释放
    // *(rhs.ps) 将会访问已经释放的内存
    i = rhs.i;
    return *this;
}
```

## 13.2.2 定义行为像指针的类

引用计数的工作方式：

* 除了初始化对象之外，每个构造函数（**拷贝构造函数除外**）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态；当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为 1
* 拷贝构造函数，拷贝给定对象的所有数据成员（包括计数器），并且递增计数器
* 析构函数递减计数器；如果计数器变为 0 ，则析构函数释放类的所有成员
* 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器；如果左侧运算对象的计数器变为 0 ，则释放原先的所有成员；最后将右侧运算对象的所有成员拷贝到左侧运算对象中。

计数器应当存放在动态内存（堆区）中，使用类中的指针成员指向计数器。

## 练习

* [练习 13.22](../src/quiz_13.22.hpp)
* [练习 13.23](../src/quiz_13.23.md)
* [练习 13.24](../src/quiz_13.24.md)
* [练习 13.25](../src/quiz_13.25.md)
* [练习 13.26](../src/quiz_13.26.md)
* [练习 13.27](../src/quiz_13.27.hpp)
* [练习 13.28](../src/quiz_13.28.hpp)
