如果我们为 HasPtr 定义了移动赋值运算符，但未改变拷贝并交换运算符，会发生什么？
编写代码验证你的答案。

> 答：会产生错误 `error: ambiguous overload for 'operator='`  
> 因为在执行 `hp1 = std::move(*pH);` 时，右值引用参数既可以匹配新定义的移动赋值运算符，也可以匹配原来的拷贝并交换运算符。因此编译器无法确定究竟使用哪一个重载函数。
